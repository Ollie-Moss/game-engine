#pragma once

#include "core/Simplex.h"
#include "core/SystemManager.h"
#include "core/Entity.h"
#include "core/Types.h"
#include "glm/common.hpp"
#include "glm/fwd.hpp"
#include "graphics/Renderer2D.h"
#include "gui/UIComponents.h"
#include <cmath>
#include <cstddef>

class UISystem : public System
{
  public:
    UISystem()
    {
        m_Signature = Simplex::GetRegistry().CreateSignature<UIElement, UIProperties, UITransform>();
    }
    void Update() override
    {
        for(Entity e : m_Entities)
        {
            auto [element, properties, transform] = e.GetComponents<UIElement, UIProperties, UITransform>();
            if(element.parent != NULL_ENTITY)
                continue;

            // this should only happen if the tree changes
            CalculateLayout(e);
            Simplex::GetRenderer().RenderImmediate(transform, NO_TEXTURE, properties.color);
            RenderElementsChildren(e, glm::vec2(0, 0));
        }
    }

    void CalculateLayout(Entity entity)
    {
        // Apply fixed sizes to transform
        SizeFixedElements(entity);

        // HUG Sizing width
        SizeHugElements(entity);

        // GROW Sizing width
        SizeGrowElements(entity, FlexDirection::Row);

        // Wrap Text - do later

        // HUG Sizing across flex direction
        SizeHugElements(entity, FlexDirection::Column);

        // GROW Sizing across flex direction
        SizeGrowElements(entity, FlexDirection::Column);

        // Calculate Positions
    }

    void SizeGrowWidths(Entity parent, std::vector<EntityId> growable)
    {
        auto [element, properties, transform] = parent.GetComponents<UIElement, UIProperties, UITransform>();

        float remainingWidth = transform.size.x;
        remainingWidth -= parentProperties.padding.left + parentProperties.padding.right;
        remainingWidth -= glm::max(0, (int)parentElement.children.size() - 1) * parentProperties.gap;

        for(Entity child : element.children)
        {
            remainingWidth -= child.GetComponent<UITransform>().size.x;
        }
        while(remainingWidth > 0)
        {
            float smallest = ((Entity)growable[0]).GetComponent<UITransform>().size.x;
            float secondSmallest = INFINITY;
            float widthToAdd = remainingWidth;

            for(Entity child : growable)
            {
                auto childTransform = child.GetComponent<UITransform>();
                if(childTransform.size.x < smallest)
                {
                }
            }
        }

        // Grow elements
        for(auto child : element.children)
        {
            SizeGrowWidths(child);
        }
    }

    void SizeFixedElements(Entity entity)
    {
        // Applies the size length on elements with sizing mode fixed
        auto [element, properties, transform] = entity.GetComponents<UIElement, UIProperties, UITransform>();
        if(properties.sizing.width.mode == SizingMode::Fixed)
        {
            transform.size.x = properties.sizing.width.length;
        };
        if(properties.sizing.height.mode == SizingMode::Fixed)
        {
            transform.size.y = properties.sizing.height.length;
        };
        for(auto child : element.children)
        {
            SizeFixedElements(child);
        }
    }
    void SizeHugElements(Entity entity)
    {
        auto [element, properties, transform] = entity.GetComponents<UIElement, UIProperties, UITransform>();

        for(auto child : element.children)
        {
            SizeHugElements(child);
        }

        glm::vec2 summedSize = glm::vec2(0, 0);
        for(auto child : element.children)
        {
            Entity childEntity = child;
            summedSize += childEntity.GetComponent<UITransform>().size;
        }

        Entity parent = element.parent;
        if(parent == NULL_ENTITY)
            parent = entity;
        auto parentProperties = parent.GetComponent<UIProperties>();
        // Apply children sizes to element
        switch(parentProperties.direction)
        {
        case FlexDirection::Row:
            if(properties.sizing.width.mode == SizingMode::Hug)
            {
                float gap = glm::max(0, (int)element.children.size() - 1) * properties.gap;
                float padding = properties.padding.left + properties.padding.right;
                transform.size.x = summedSize.x + padding + gap;
            }
            break;
        case FlexDirection::Column:
            if(properties.sizing.height.mode == SizingMode::Hug)
            {
                float gap = glm::max(0, (int)element.children.size() - 1) * properties.gap;
                float padding = properties.padding.top + properties.padding.bottom;
                transform.size.y = summedSize.y + padding + gap;
            }
            break;
        }
    };

    void RenderElementsChildren(Entity entity, glm::vec2 offset)
    {
        auto [element, properties, transform] = entity.GetComponents<UIElement, UIProperties, UITransform>();

        float leftOffset = properties.padding.left;
        if(element.children.empty())
            return;

        for(Entity child : element.children)
        {
            auto [childElement, childProperties, childTransform] = child.GetComponents<UIElement, UIProperties, UITransform>();

            glm::vec2 childPosition = transform.position + childTransform.position + offset;
            childPosition.x += leftOffset;
            childPosition.y += properties.padding.top;

            Simplex::GetRenderer().RenderImmediate({.position = glm::vec3(childPosition, 0), .size = childTransform.size}, NO_TEXTURE, childProperties.color);
            leftOffset += childTransform.size.x + properties.gap;
            RenderElementsChildren(child, childPosition);
        }
    }

    void RecalculateLayout() {}
};
